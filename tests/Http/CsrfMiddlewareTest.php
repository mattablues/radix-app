<?php

declare(strict_types=1);

namespace Radix\Tests\Http;

use App\Middlewares\Csrf;
use PHPUnit\Framework\TestCase;
use Radix\Http\Request;
use Radix\Http\RequestHandlerInterface;
use Radix\Http\Response;
use Radix\Session\SessionInterface;

final class CsrfMiddlewareTest extends TestCase
{
    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $projectRoot = dirname(__DIR__, 2);

        if (!defined('ROOT_PATH')) {
            define('ROOT_PATH', $projectRoot);
        }
    }

    private function runMw(Request $req, string $sessionToken): Response
    {
        $session = new class ($sessionToken) implements SessionInterface {
            private bool $started = true;
            private string $token;
            /** @var array<string,mixed> */
            private array $store = [];

            public function __construct(string $t)
            {
                $this->token = $t;
                $this->store['csrf_token'] = $t;
                $this->store['csrf_time'] = time();
            }

            public function isStarted(): bool
            {
                return $this->started;
            }
            public function start(): bool
            {
                $this->started = true;
                return true;
            }
            public function destroy(): void
            {
                $this->store = [];
                $this->started = false;
            }
            public function clear(): void
            {
                $this->store = [];
            }
            public function isAuthenticated(): bool
            {
                return false;
            }

            public function setCsrfToken(): string
            {
                $this->store['csrf_token'] = $this->token;
                $this->store['csrf_time'] = time();
                return $this->token;
            }

            public function csrf(): string
            {
                $token = $this->store['csrf_token'] ?? $this->setCsrfToken();
                // Säkerställ sträng enligt interface/produktionen
                if (!is_string($token)) {
                    return $this->setCsrfToken();
                }
                return $token;
            }

            public function validateCsrfToken(?string $token): void
            { /* no-op för test */
            }

            public function set(string $key, mixed $value): void
            {
                $this->store[$key] = $value;
            }
            public function get(string $key, mixed $default = null): mixed
            {
                return $this->store[$key] ?? $default;
            }
            public function has(string $key): bool
            {
                return array_key_exists($key, $this->store);
            }
            public function remove(string $key): void
            {
                unset($this->store[$key]);
            }

            public function setFlashMessage(string $message, string $type = 'success', array $params = []): void
            {
                $this->store['flash_notification'] = ['body' => $message, 'type' => $type] + $params;
            }

            /**
             * @return array<string,mixed>|null
             */
            public function flashMessage(): ?array
            {
                $msg = $this->store['flash_notification'] ?? null;
                if (!is_array($msg)) {
                    return null;
                }

                /** @var array<string,mixed> $msg */
                return $msg;
            }

            public function isValid(): bool
            {
                return true;
            }
        };

        $req->setSession($session);

        $mw = new Csrf();
        $next = new class implements RequestHandlerInterface {
            public function handle(Request $request): Response
            {
                $r = new Response();
                $r->setBody('ok');
                return $r;
            }
        };

        return $mw->process($req, $next);
    }

    /**
     * @param array<string,mixed> $post
     * @param array<string,mixed> $server
     */
    private function makeReq(string $method, array $post = [], array $server = []): Request
    {
        /** @var array<string,mixed> $get */
        $get = [];
        /** @var array<string,mixed> $files */
        $files = [];
        /** @var array<string,mixed> $cookie */
        $cookie = [];

        return new Request('/', $method, $get, $post, $files, $cookie, $server);
    }

    public function testMethodIsUppercasedForProtection(): void
    {
        $token = 'ABC123';
        $req = $this->makeReq('post', ['csrf_token' => $token]);
        $resp = $this->runMw($req, $token);
        $this->assertSame(200, $resp->getStatusCode());
    }

    public function testProvidedTokenPrefersNonEmptyFormTokenOtherwiseHeader(): void
    {
        $sessionToken = 'T123';

        $req1 = $this->makeReq('POST', ['csrf_token' => ''], ['HTTP_X_CSRF_TOKEN' => $sessionToken]);
        $resp1 = $this->runMw($req1, $sessionToken);
        $this->assertSame(200, $resp1->getStatusCode());

        $req2 = $this->makeReq('POST', ['csrf_token' => $sessionToken]);
        $resp2 = $this->runMw($req2, $sessionToken);
        $this->assertSame(200, $resp2->getStatusCode());

        // För felvägen: kapsla i output buffering och stäng själv
        $req3 = $this->makeReq('POST', [], ['HTTP_X_CSRF_TOKEN' => 'WRONG']);
        ob_start();
        try {
            $resp3 = $this->runMw($req3, $sessionToken);
            $this->assertSame(419, $resp3->getStatusCode());
        } finally {
            ob_end_clean();
        }
    }

    public function testLowercaseMethodIsStillProtectedViaUppercase(): void
    {
        $sessionToken = 'REAL_TOKEN';
        $badToken = 'WRONG_TOKEN';

        // Metod i gemener, men fel token → ska fortfarande skyddas (419)
        $req = $this->makeReq('post', ['csrf_token' => $badToken]);

        ob_start();
        try {
            $resp = $this->runMw($req, $sessionToken);
            $this->assertSame(419, $resp->getStatusCode());
        } finally {
            ob_end_clean();
        }
    }
}
