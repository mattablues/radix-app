----------------------------------------------------------------------------------------------
Git Hub Actions
----------------------------------------------------------------------------------------------
- Name: ENABLE_FRONTEND_BUILD, Value: 1 eller 0
- Name: ENABLE_INFECTION_ON_PR, Value: 1 eller 0

Då styrs workflow utan att ändra YAML. När du skapar nya appar från templaten kan du sätta
variablerna per repo under Settings -> Actions -> Secrets and variables -> Variables.

Nej, du behöver inte sätta dem i template‑repon nu. Låt YAML:en ha rimliga
default (t.ex. båda = '1'). När du skapar en ny app från templaten sätter du
variablerna i den appens repo vid behov. Detta gör templaten generisk och varje app kan styra
själv utan att ändra workflowfiler.

----------------------------------------------------------------------------------------------
Inflection
----------------------------------------------------------------------------------------------
composer infect -- --filter=src/Controllers/Api/HealthController.php   --show-mutations

    vendor/bin/infection --threads=1 --min-msi=20 --min-covered-msi=20


vendor/bin/infection --threads=1 --show-mutations --filter=src/Middlewares/RateLimiter.php
--initial-tests-php-options="-d opcache.enable_cli=0"

----------------------------------------------------------------------------------------------
Cors
----------------------------------------------------------------------------------------------
Utveckling (tillåt Vite/localhost):
CORS_ALLOW_ORIGIN=http://localhost:5173
CORS_ALLOW_CREDENTIALS=1
Produktion (en specifik domän, med credentials):
CORS_ALLOW_ORIGIN=https://app.example.com
CORS_ALLOW_CREDENTIALS=1
Öppen (inte rekommenderat med credentials):
CORS_ALLOW_ORIGIN=*
CORS_ALLOW_CREDENTIALS=0

Globalt för gruppen: ['request.id','api.logger','api.throttle']
Per route hårdare: ->middleware(['api.throttle.hard'])
Mindre strikt: ->middleware(['api.throttle.light'])

Sänka kvoten per route? Skapa fler alias (t.ex. api.throttle.light) via containern med
andra ctor‑värden.
Logga svarstid som header globalt? Lägg ett enkelt middleware som
sätter X-Response-Time (du har redan X-Response-Time i svaret, så bra).
Lägga test för 429 och headers? Jag kan skissa ett PHPUnit-test

RequestLogger: ja, använd både på API och webbrutter (ger spårning/fejsökning överallt).
RateLimiter: primärt på API. På webbrutter endast på “heta”
endpoints (t.ex. formulär POST, auth, sök) eller publika sidor som riskerar missbruk.
Använd “light” policy för webben.

Praktiskt:
API-grupp: ['request.id','api.logger','api.throttle'].
Webb-grupp: ['request.id','api.logger'] och selektivt lägg till 'api.throttle.light'
på specifika rutter (t.ex. POST /login, POST /contact).

----------------------------------------------------------------------------------------------
PHPStan
----------------------------------------------------------------------------------------------
- composer phpstan
- vendor/bin/phpstan analyse -c phpstan.neon.dist

Grundstruktur
Filnamn: phpstan.neon eller phpstan.neon.dist
Körning: vendor/bin/phpstan analyse -c phpstan.neon.dist
Basparametrar
level: 0–9 (högre = striktare). Rekommenderat att börja på 4–5 och höja gradvis.
paths: vilka mappar/fil(er) som ska analyseras.
autoload_files: filer att autoloada (helpers etc.) innan analysen.
bootstrapFiles: PHP-filer som körs före analys (kan sätta upp autoloader, constants).
scanFiles / scanDirectories: extra filer/mappar att scanna utan att analysera dem
(nyttigt för meta/registrering).
inferPrivatePropertyTypeFromConstructor: true = PHPStan gissar typ från konstruktor.
treatPhpDocTypesAsCertain: false = var lite försiktigare med PHPDoc-typer.
reportUnmatchedIgnoredErrors: true = om en ignoreErrors-regex inte matchar något fel,
rapportera det (bra för städning).
Exempel: minimal parameters: level: 5 paths: - framework/src
Exempel: lite mer komplett parameters: level: 5 paths: - framework/src - src
autoload_files: - framework/support/helpers.php - support/helpers.php bootstrapFiles: -
vendor/autoload.php inferPrivatePropertyTypeFromConstructor: true treatPhpDocTypesAsCertain:
false reportUnmatchedIgnoredErrors: true ignoreErrors

Använd sparsamt och snävt. Mönstret är en regex.
Bra när du har dynamiska ORM-magic-metoder som PHPStan inte kan härleda korrekt.
Exempel: ignorera ett specifikt dynamiskt anrop parameters: ignoreErrors: -
'#Call to an undefined method App\Models\.*::relation()#'
Exempel: ignorera en enskild varning i en fil på en viss rad (mer exakt)
parameters: ignoreErrors: - message: '#Call to an undefined method
App\Models\User::relation()#' paths: - src/Models/User.php count: 1

Tips:
Lägg hellre en @phpstan-ignore-next-line i koden vid falsk positiv än en bred ignore i konfig.
Håll ignoreErrors-listan kort och dokumenterad.
includes (modulär konfig)
Du kan bryta upp konfig i flera filer och inkludera dem.
Exempel: includes:
phpstan-baseline.neon
phpstan-strict.neon
Baselines
PHPStan kan skapa en baseline av nuvarande fel som ignoreras tills du fixar dem gradvis.
Skapa: vendor/bin/phpstan analyse -c phpstan.neon.dist --generate-baseline
Använd: lägg till includes: - phpstan-baseline.neon
Exempel med baseline includes:
phpstan-baseline.neon parameters: level: 6 paths:
framework/src
Levels
0: minst strikt
1–3: grundläggande typer
4–5: bra balans för medelstora projekt
6–7: striktare, fler falska positiva om mycket magic/dynamik
8–9: väldigt strikt, kräver vältypad kodbas
Tilläggsplugins
doctrine: doctrine/orm + phpstan/phpstan-doctrine
laravel: nunomaduro/larastan (för Laravel-projekt)
generics: phpstan/phpstan-strict-rules (striktare regler)
Exempel scripts i composer.json "scripts": { "phpstan": "vendor/bin/phpstan analyse -c
phpstan.neon.dist", "phpstan:baseline": "vendor/bin/phpstan analyse -c phpstan.neon.dist
--generate-baseline", "phpstan:max": "vendor/bin/phpstan analyse -c phpstan.neon.dist
--level=max" }

Filtrera bort mappar
excludePaths: uteslut kataloger/filer från analys.
Exempel: parameters: excludePaths: - vendor - storage - cache -
framework/src/Database/Migrations/Legacy/*

Kontextberoende autoload/const
bootstrapFiles kan sätta upp konstanta värden, t.ex. define('APP_ENV', 'testing');
Exempel: parameters: bootstrapFiles: - tools/bootstrap-phpstan.php
tools/bootstrap-phpstan.php:

parameters:
    level: 6
    paths:
        - src
        - framework/src
        - tests
    reportUnmatchedIgnoredErrors: true
    inferPrivatePropertyTypeFromConstructor: true
    treatPhpDocTypesAsCertain: false
    bootstrapFiles:
    - tools/phpstan-bootstrap.php

----------------------------------------------------------------------------------------------
FileCache
----------------------------------------------------------------------------------------------
use Radix\Support\FileCache;

final class StatsController extends ApiController
{
    public function daily(): \Radix\Http\JsonResponse
    {
        $cache = app(FileCache::class);
        $key = 'stats:daily:' . date('Y-m-d');

        $data = $cache->get($key);
        if ($data === null) {
            // Gör dyr beräkning/hämtning
            $data = [
                'users' => User::query()->count('*', 'c')->value('c'),
                'orders' => Order::query()->count('*', 'c')->value('c'),
            ];
            $cache->set($key, $data, 300); // cache 5 min
        }

        return $this->json(['success' => true, 'data' => $data]);
    }
}

----------------------------------------------------------------------------------------------
Pivot
----------------------------------------------------------------------------------------------
<?php

use App\Models\User;
use App\Models\Role;

class RoleUserController
{
    // Lägg till roller till en användare (med pivot-fält)
    public function addRolesToUser(int $userId): void
    {
        $user = User::find($userId);

        // Anta att User har: public function roles() { return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id'); }
        // Hämta roller och inkludera pivot-kolumnen "note" i resultatet
        $roles = $user->roles()->withPivot('note')->get();

        // Lägg till en roll utan extra pivot-data
        $user->roles()->attach(1);

        // Lägg till en roll med pivot-attribut
        $user->roles()->attach(2, ['note' => 'primary']);

        // Lägg till flera på en gång, blandat format
        $user->roles()->attach([
            3,                              // utan pivot-data
            4 => ['note' => 'backup'],      // med pivot-data
        ]);
    }

    // Ta bort roller
    public function removeRolesFromUser(int $userId): void
    {
        $user = User::find($userId);

        // Ta bort en specifik roll
        $user->roles()->detach(3);

        // Ta bort flera specifika
        $user->roles()->detach([1, 2]);

        // Ta bort alla roller för användaren
        $user->roles()->detach();
    }

    // Synka roller (lägg till/uppdatera och ev. ta bort övriga)
    public function syncUserRoles(int $userId): void
    {
        $user = User::find($userId);

        // Synka till exakt dessa roller och pivot-värden
        // - roll 2 uppdateras (note=manager)
        // - roll 5 läggs till (note=editor)
        // - alla andra roller tas bort (detaching=true)
        $user->roles()->sync([
            2 => ['note' => 'manager'],
            5 => ['note' => 'editor'],
        ], true);

        // Alternativ: synka utan att ta bort övriga (detaching=false)
        $user->roles()->sync([
            7 => ['note' => 'contributor'],
        ], false);
    }

    // Hämta med pivot-data
    public function listUserRolesWithNotes(int $userId): array
    {
        $user = User::find($userId);

        $roles = $user->roles()->withPivot('note')->get();

        // Exempel: läsa pivot-data per roll
        return array_map(function (Role $role) {
            $pivot = $role->getRelation('pivot') ?? $role->getAttribute('pivot');
            return [
                'role_id' => $role->id,
                'name' => $role->name,
                'note' => is_array($pivot) ? ($pivot['note'] ?? null) : null,
            ];
        }, $roles);
    }
}

$users = User::query()
    ->with([
        'roles' => function (\Radix\Database\QueryBuilder\QueryBuilder $q) {
            // filtera relaterade roller
            $q->where('status', '=', 'active')->orderBy('name');
        },
    ])
    ->get();

// och när du hämtar från själva relationen (ej via eager load):
$user->roles()->withPivot('note')->get();

with eager load:

$users = User::query()
    ->with([
        'posts' => function (\Radix\Database\QueryBuilder\QueryBuilder $q) {
            $q->where('status', '=', 'published')->orderBy('created_at', 'DESC')->limit(5);
        },
        'roles' => function (\Radix\Database\QueryBuilder\QueryBuilder $q) {
            $q->where('name', '!=', 'banned');
        },
    ])
    ->get();

----------------------------------------------------------------------------------------------
Query support
----------------------------------------------------------------------------------------------
<?php

use App\Models\User;
use Radix\Database\QueryBuilder\QueryBuilder;

// Hämta användare och eager-loada:
// - posts: endast 'published', sorterade nyast först, begränsa till 5
// - roles: endast 'active', sorterade på namn
$users = User::query()
    ->with([
        'posts' => function (QueryBuilder $q) {
            $q->where('status', '=', 'published')
              ->orderBy('created_at', 'DESC')
              ->limit(5);
        },
        'roles' => function (QueryBuilder $q) {
            $q->where('status', '=', 'active')
              ->orderBy('name', 'ASC');
        },
    ])
    ->get();

// Användning av resultaten
foreach ($users as $user) {
    echo $user->first_name . PHP_EOL;

    // Filtrerade posts (från with-closure)
    $posts = $user->getRelation('posts') ?? [];
    foreach ($posts as $post) {
        echo " - Post: {$post->title} ({$post->status})" . PHP_EOL;
    }

    // Filtrerade roles (från with-closure)
    $roles = $user->getRelation('roles') ?? [];
    foreach ($roles as $role) {
        echo " - Role: {$role->name} ({$role->status})" . PHP_EOL;
    }
}

<?php

use App\Models\User;
use Radix\Database\QueryBuilder\QueryBuilder;

$user = User::find(1);

// Bygg relationens QueryBuilder (JOIN pivot + WHERE pivot.user_id = 1),
// applicera ett filter, och inkludera pivot-kolumnen 'note' i SELECT.
$roles = $user->roles()
    ->withPivot('note')
    ->query() // ← nytt: får QueryBuilder kopplad till relationen
    ->where('status', '=', 'active')
    ->orderBy('name', 'ASC')
    ->get();

// Läs pivot-data (note)
foreach ($roles as $role) {
    $pivot = $role->getRelation('pivot') ?? $role->getAttribute('pivot');
    $note = is_array($pivot) ? ($pivot['note'] ?? null) : null;
    echo "{$role->name} (note: {$note})" . PHP_EOL;
}

<?php

use App\Models\User;
use Radix\Database\QueryBuilder\QueryBuilder;

$users = User::query()
    ->with([
        // HasMany: filtrera poster
        'posts' => function (QueryBuilder $q) {
            $q->where('status', '=', 'published');
        },
        // BelongsToMany: filtrera roller via QB i relationen
        'roles' => function (QueryBuilder $q) {
            $q->where('status', '=', 'active');
        },
    ])
    ->get();

// Om du behöver pivot-fält i eager loading-scenariot:
foreach ($users as $user) {
    // Ladda roller med pivotfält separat via relationen
    $activeRolesWithNotes = $user->roles()
        ->withPivot('note')
        ->query()
        ->where('status', '=', 'active')
        ->get();

    $user->setRelation('roles_with_notes', $activeRolesWithNotes);
}